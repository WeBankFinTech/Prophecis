// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// MountInfo mount info
// swagger:model MountInfo
type MountInfo struct {

	// Data access mode
	// Enum: [ReadWriteOnce ReadWriteMany ReadOnlyMany]
	AccessMode *string `json:"accessMode,omitempty"`

	// Local Path or Kubernetes PV/PVC
	// Required: true
	LocalPath *string `json:"localPath"`

	// Container path
	// Required: true
	MountPath *string `json:"mountPath"`

	// Mount type
	// Required: true
	// Enum: [New Existing None]
	MountType *string `json:"mountType"`

	// Storage capacity
	// Required: true
	Size *int64 `json:"size"`

	// subPath of localpath
	SubPath string `json:"subPath,omitempty"`
}

// Validate validates this mount info
func (m *MountInfo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAccessMode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocalPath(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMountPath(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMountType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var mountInfoTypeAccessModePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ReadWriteOnce","ReadWriteMany","ReadOnlyMany"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		mountInfoTypeAccessModePropEnum = append(mountInfoTypeAccessModePropEnum, v)
	}
}

const (

	// MountInfoAccessModeReadWriteOnce captures enum value "ReadWriteOnce"
	MountInfoAccessModeReadWriteOnce string = "ReadWriteOnce"

	// MountInfoAccessModeReadWriteMany captures enum value "ReadWriteMany"
	MountInfoAccessModeReadWriteMany string = "ReadWriteMany"

	// MountInfoAccessModeReadOnlyMany captures enum value "ReadOnlyMany"
	MountInfoAccessModeReadOnlyMany string = "ReadOnlyMany"
)

// prop value enum
func (m *MountInfo) validateAccessModeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, mountInfoTypeAccessModePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *MountInfo) validateAccessMode(formats strfmt.Registry) error {

	if swag.IsZero(m.AccessMode) { // not required
		return nil
	}

	// value enum
	if err := m.validateAccessModeEnum("accessMode", "body", *m.AccessMode); err != nil {
		return err
	}

	return nil
}

func (m *MountInfo) validateLocalPath(formats strfmt.Registry) error {

	if err := validate.Required("localPath", "body", m.LocalPath); err != nil {
		return err
	}

	return nil
}

func (m *MountInfo) validateMountPath(formats strfmt.Registry) error {

	if err := validate.Required("mountPath", "body", m.MountPath); err != nil {
		return err
	}

	return nil
}

var mountInfoTypeMountTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["New","Existing","None"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		mountInfoTypeMountTypePropEnum = append(mountInfoTypeMountTypePropEnum, v)
	}
}

const (

	// MountInfoMountTypeNew captures enum value "New"
	MountInfoMountTypeNew string = "New"

	// MountInfoMountTypeExisting captures enum value "Existing"
	MountInfoMountTypeExisting string = "Existing"

	// MountInfoMountTypeNone captures enum value "None"
	MountInfoMountTypeNone string = "None"
)

// prop value enum
func (m *MountInfo) validateMountTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, mountInfoTypeMountTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *MountInfo) validateMountType(formats strfmt.Registry) error {

	if err := validate.Required("mountType", "body", m.MountType); err != nil {
		return err
	}

	// value enum
	if err := m.validateMountTypeEnum("mountType", "body", *m.MountType); err != nil {
		return err
	}

	return nil
}

func (m *MountInfo) validateSize(formats strfmt.Registry) error {

	if err := validate.Required("size", "body", m.Size); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MountInfo) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MountInfo) UnmarshalBinary(b []byte) error {
	var res MountInfo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
