// Code generated by go-swagger; DO NOT EDIT.

package restmodels

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
)

// Model model
// swagger:model Model
type Model struct {
	BasicNewModel

	// Job Alert String.
	JobAlert string `json:"JobAlert,omitempty"`

	// Job Type.
	JobType string `json:"JobType,omitempty"`

	// TFosRequest
	TFosRequest *TFosRequest `json:"TFosRequest,omitempty"`

	// api type of xgboost or lightgbm
	APIType string `json:"api_type,omitempty"`

	// code_selector type file
	CodeSelector string `json:"code_selector,omitempty"`

	// completed timestamp of the job
	CompletedTimestamp string `json:"completed_timestamp,omitempty"`

	// data set
	DataSet *DataSet `json:"data_set,omitempty"`

	// data stores
	DataStores []*Datastore `json:"data_stores"`

	// Detailed description of deep learning model.
	Description string `json:"description,omitempty"`

	// Experiment Name
	ExpName string `json:"expName,omitempty"`

	// Experiment Run Id
	ExpRunID string `json:"expRunId,omitempty"`

	// Code File's Name
	FileName string `json:"fileName,omitempty"`

	// Code File's Path
	FilePath string `json:"filePath,omitempty"`

	// framework
	Framework *Framework `json:"framework,omitempty"`

	// job's namespace.
	JobNamespace string `json:"job_namespace,omitempty"`

	// algorithm of training job
	JobParams string `json:"job_params,omitempty"`

	// The name of the deep learning model.
	Name string `json:"name,omitempty"`

	// proxy user of job
	ProxyUser string `json:"proxy_user,omitempty"`

	// Count of Param Server
	PsCPU string `json:"ps_cpu,omitempty"`

	// Count of Param Server
	PsImage string `json:"ps_image,omitempty"`

	// Count of Param Server
	PsMemory string `json:"ps_memory,omitempty"`

	// Count of Param Server
	Pss string `json:"pss,omitempty"`

	// submission timestamp of the job.
	SubmissionTimestamp string `json:"submission_timestamp,omitempty"`

	// submit_id describe user submit
	SubmitID string `json:"submit_id,omitempty"`

	// training
	Training *Training `json:"training,omitempty"`

	// user name.
	UserID string `json:"user_id,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *Model) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 BasicNewModel
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	m.BasicNewModel = aO0

	// AO1
	var dataAO1 struct {
		JobAlert string `json:"JobAlert,omitempty"`

		JobType string `json:"JobType,omitempty"`

		TFosRequest *TFosRequest `json:"TFosRequest,omitempty"`

		APIType string `json:"api_type,omitempty"`

		CodeSelector string `json:"code_selector,omitempty"`

		CompletedTimestamp string `json:"completed_timestamp,omitempty"`

		DataSet *DataSet `json:"data_set,omitempty"`

		DataStores []*Datastore `json:"data_stores"`

		Description string `json:"description,omitempty"`

		ExpName string `json:"expName,omitempty"`

		ExpRunID string `json:"expRunId,omitempty"`

		FileName string `json:"fileName,omitempty"`

		FilePath string `json:"filePath,omitempty"`

		Framework *Framework `json:"framework,omitempty"`

		JobNamespace string `json:"job_namespace,omitempty"`

		JobParams string `json:"job_params,omitempty"`

		Name string `json:"name,omitempty"`

		ProxyUser string `json:"proxy_user,omitempty"`

		PsCPU string `json:"ps_cpu,omitempty"`

		PsImage string `json:"ps_image,omitempty"`

		PsMemory string `json:"ps_memory,omitempty"`

		Pss string `json:"pss,omitempty"`

		SubmissionTimestamp string `json:"submission_timestamp,omitempty"`

		SubmitID string `json:"submit_id,omitempty"`

		Training *Training `json:"training,omitempty"`

		UserID string `json:"user_id,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.JobAlert = dataAO1.JobAlert

	m.JobType = dataAO1.JobType

	m.TFosRequest = dataAO1.TFosRequest

	m.APIType = dataAO1.APIType

	m.CodeSelector = dataAO1.CodeSelector

	m.CompletedTimestamp = dataAO1.CompletedTimestamp

	m.DataSet = dataAO1.DataSet

	m.DataStores = dataAO1.DataStores

	m.Description = dataAO1.Description

	m.ExpName = dataAO1.ExpName

	m.ExpRunID = dataAO1.ExpRunID

	m.FileName = dataAO1.FileName

	m.FilePath = dataAO1.FilePath

	m.Framework = dataAO1.Framework

	m.JobNamespace = dataAO1.JobNamespace

	m.JobParams = dataAO1.JobParams

	m.Name = dataAO1.Name

	m.ProxyUser = dataAO1.ProxyUser

	m.PsCPU = dataAO1.PsCPU

	m.PsImage = dataAO1.PsImage

	m.PsMemory = dataAO1.PsMemory

	m.Pss = dataAO1.Pss

	m.SubmissionTimestamp = dataAO1.SubmissionTimestamp

	m.SubmitID = dataAO1.SubmitID

	m.Training = dataAO1.Training

	m.UserID = dataAO1.UserID

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m Model) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	aO0, err := swag.WriteJSON(m.BasicNewModel)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)

	var dataAO1 struct {
		JobAlert string `json:"JobAlert,omitempty"`

		JobType string `json:"JobType,omitempty"`

		TFosRequest *TFosRequest `json:"TFosRequest,omitempty"`

		APIType string `json:"api_type,omitempty"`

		CodeSelector string `json:"code_selector,omitempty"`

		CompletedTimestamp string `json:"completed_timestamp,omitempty"`

		DataSet *DataSet `json:"data_set,omitempty"`

		DataStores []*Datastore `json:"data_stores"`

		Description string `json:"description,omitempty"`

		ExpName string `json:"expName,omitempty"`

		ExpRunID string `json:"expRunId,omitempty"`

		FileName string `json:"fileName,omitempty"`

		FilePath string `json:"filePath,omitempty"`

		Framework *Framework `json:"framework,omitempty"`

		JobNamespace string `json:"job_namespace,omitempty"`

		JobParams string `json:"job_params,omitempty"`

		Name string `json:"name,omitempty"`

		ProxyUser string `json:"proxy_user,omitempty"`

		PsCPU string `json:"ps_cpu,omitempty"`

		PsImage string `json:"ps_image,omitempty"`

		PsMemory string `json:"ps_memory,omitempty"`

		Pss string `json:"pss,omitempty"`

		SubmissionTimestamp string `json:"submission_timestamp,omitempty"`

		SubmitID string `json:"submit_id,omitempty"`

		Training *Training `json:"training,omitempty"`

		UserID string `json:"user_id,omitempty"`
	}

	dataAO1.JobAlert = m.JobAlert

	dataAO1.JobType = m.JobType

	dataAO1.TFosRequest = m.TFosRequest

	dataAO1.APIType = m.APIType

	dataAO1.CodeSelector = m.CodeSelector

	dataAO1.CompletedTimestamp = m.CompletedTimestamp

	dataAO1.DataSet = m.DataSet

	dataAO1.DataStores = m.DataStores

	dataAO1.Description = m.Description

	dataAO1.ExpName = m.ExpName

	dataAO1.ExpRunID = m.ExpRunID

	dataAO1.FileName = m.FileName

	dataAO1.FilePath = m.FilePath

	dataAO1.Framework = m.Framework

	dataAO1.JobNamespace = m.JobNamespace

	dataAO1.JobParams = m.JobParams

	dataAO1.Name = m.Name

	dataAO1.ProxyUser = m.ProxyUser

	dataAO1.PsCPU = m.PsCPU

	dataAO1.PsImage = m.PsImage

	dataAO1.PsMemory = m.PsMemory

	dataAO1.Pss = m.Pss

	dataAO1.SubmissionTimestamp = m.SubmissionTimestamp

	dataAO1.SubmitID = m.SubmitID

	dataAO1.Training = m.Training

	dataAO1.UserID = m.UserID

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this model
func (m *Model) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with BasicNewModel
	if err := m.BasicNewModel.Validate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTFosRequest(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDataSet(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDataStores(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFramework(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTraining(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Model) validateTFosRequest(formats strfmt.Registry) error {

	if swag.IsZero(m.TFosRequest) { // not required
		return nil
	}

	if m.TFosRequest != nil {
		if err := m.TFosRequest.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("TFosRequest")
			}
			return err
		}
	}

	return nil
}

func (m *Model) validateDataSet(formats strfmt.Registry) error {

	if swag.IsZero(m.DataSet) { // not required
		return nil
	}

	if m.DataSet != nil {
		if err := m.DataSet.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("data_set")
			}
			return err
		}
	}

	return nil
}

func (m *Model) validateDataStores(formats strfmt.Registry) error {

	if swag.IsZero(m.DataStores) { // not required
		return nil
	}

	for i := 0; i < len(m.DataStores); i++ {
		if swag.IsZero(m.DataStores[i]) { // not required
			continue
		}

		if m.DataStores[i] != nil {
			if err := m.DataStores[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("data_stores" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Model) validateFramework(formats strfmt.Registry) error {

	if swag.IsZero(m.Framework) { // not required
		return nil
	}

	if m.Framework != nil {
		if err := m.Framework.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("framework")
			}
			return err
		}
	}

	return nil
}

func (m *Model) validateTraining(formats strfmt.Registry) error {

	if swag.IsZero(m.Training) { // not required
		return nil
	}

	if m.Training != nil {
		if err := m.Training.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("training")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Model) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Model) UnmarshalBinary(b []byte) error {
	var res Model
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
